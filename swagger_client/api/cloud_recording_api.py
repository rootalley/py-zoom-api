# coding: utf-8

"""
    Zoom API

    The Zoom API allows developers to safely and securely access information from Zoom. You can use this API to build private services or public applications on the [Zoom App Marketplace](http://marketplace.zoom.us). To learn how to get your credentials and create private/public applications, read our [Authorization Guide](https://marketplace.zoom.us/docs/guides/authorization/credentials). All endpoints are available via `https` and are located at `api.zoom.us/v2/`.  For instance you can list all users on an account via `https://api.zoom.us/v2/users/`.  # noqa: E501

    OpenAPI spec version: 2.0.0
    Contact: developersupport@zoom.us
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class CloudRecordingApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_account_cloud_recording(self, account_id, **kwargs):  # noqa: E501
        """List Recordings of an Account  # noqa: E501

        List [Cloud Recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) available on an Account.  > To access a password protected cloud recording, add an \"access_token\" parameter to the download URL and provide [JWT](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app) as the value of the \"access_token\". <br> **Prerequisites**:<br> * A Pro or a higher paid plan with Cloud Recording option enabled.<br> **Scopes**: `recording:read:admin` or `account:read:admin`  If the scope `recording:read:admin` is used, the Account ID of the Account must be provided in the `accountId` path parameter to list recordings that belong to the Account. This scope only works for Sub Accounts.   To list recordings of a Master Account, the scope must be `account:read:admin` and the value of `accountId` should be `me`.<br>  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_cloud_recording(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Unique identifier of the account. (required)
        :param int page_size: The number of records returned within a single API call.
        :param str next_page_token: The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
        :param datetime _from: The start date for the monthly range for which you would like to retrieve recordings. The maximum range can be a month. The month should fall within the past six months period from the date of query.
        :param datetime to: The end date for the monthly range for which you would like to retrieve recordings. The maximum range can be a month. The month should fall within the past six months period from the date of query.
        :return: InlineResponse20073
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_cloud_recording_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_cloud_recording_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_cloud_recording_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List Recordings of an Account  # noqa: E501

        List [Cloud Recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) available on an Account.  > To access a password protected cloud recording, add an \"access_token\" parameter to the download URL and provide [JWT](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app) as the value of the \"access_token\". <br> **Prerequisites**:<br> * A Pro or a higher paid plan with Cloud Recording option enabled.<br> **Scopes**: `recording:read:admin` or `account:read:admin`  If the scope `recording:read:admin` is used, the Account ID of the Account must be provided in the `accountId` path parameter to list recordings that belong to the Account. This scope only works for Sub Accounts.   To list recordings of a Master Account, the scope must be `account:read:admin` and the value of `accountId` should be `me`.<br>  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_cloud_recording_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Unique identifier of the account. (required)
        :param int page_size: The number of records returned within a single API call.
        :param str next_page_token: The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
        :param datetime _from: The start date for the monthly range for which you would like to retrieve recordings. The maximum range can be a month. The month should fall within the past six months period from the date of query.
        :param datetime to: The end date for the monthly range for which you would like to retrieve recordings. The maximum range can be a month. The month should fall within the past six months period from the date of query.
        :return: InlineResponse20073
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'page_size', 'next_page_token', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_cloud_recording" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_cloud_recording`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['accountId'] = params['account_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page_token' in params:
            query_params.append(('next_page_token', params['next_page_token']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{accountId}/recordings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20073',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def meeting_recording_registrant_create(self, body, meeting_id, **kwargs):  # noqa: E501
        """Create a Recording Registrant  # noqa: E501

        Cloud Recordings of past Zoom Meetings can be made [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings). Users should be [registered](https://marketplace.zoom.us/docs/api-reference/zoom-api/cloud-recording/meetingrecordingregistrantcreate) to view these recordings.  Use this API to register a user to gain access to **On-demand Cloud Recordings** of a past meeting.<br> **Scopes:** `recording:write:admin`, `recording:write`.<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meeting_recording_registrant_create(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body66 body: (required)
        :param int meeting_id: The meeting ID in **long** format. The data type of this field is \"long\"(represented as int64 in JSON).  While storing it in your database, store it as a **long** data type and **not as an integer**, as the Meeting IDs can be longer than 10 digits. (required)
        :return: InlineResponse20113
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.meeting_recording_registrant_create_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.meeting_recording_registrant_create_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
            return data

    def meeting_recording_registrant_create_with_http_info(self, body, meeting_id, **kwargs):  # noqa: E501
        """Create a Recording Registrant  # noqa: E501

        Cloud Recordings of past Zoom Meetings can be made [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings). Users should be [registered](https://marketplace.zoom.us/docs/api-reference/zoom-api/cloud-recording/meetingrecordingregistrantcreate) to view these recordings.  Use this API to register a user to gain access to **On-demand Cloud Recordings** of a past meeting.<br> **Scopes:** `recording:write:admin`, `recording:write`.<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meeting_recording_registrant_create_with_http_info(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body66 body: (required)
        :param int meeting_id: The meeting ID in **long** format. The data type of this field is \"long\"(represented as int64 in JSON).  While storing it in your database, store it as a **long** data type and **not as an integer**, as the Meeting IDs can be longer than 10 digits. (required)
        :return: InlineResponse20113
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method meeting_recording_registrant_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `meeting_recording_registrant_create`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `meeting_recording_registrant_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/registrants', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20113',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def meeting_recording_registrant_status(self, body, meeting_id, **kwargs):  # noqa: E501
        """Update Recording Registrant's Status  # noqa: E501

        A registrant can either be approved or denied from viewing the [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) recording.  Use this API to update a registrant's status.  **Scopes:** `recording:write:admin`, `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meeting_recording_registrant_status(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body68 body: (required)
        :param int meeting_id: The meeting ID in **long** format. The data type of this field is \"long\"(represented as int64 in JSON).  While storing it in your database, store it as a **long** data type and **not as an integer**, as the Meeting IDs can be longer than 10 digits. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.meeting_recording_registrant_status_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.meeting_recording_registrant_status_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
            return data

    def meeting_recording_registrant_status_with_http_info(self, body, meeting_id, **kwargs):  # noqa: E501
        """Update Recording Registrant's Status  # noqa: E501

        A registrant can either be approved or denied from viewing the [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) recording.  Use this API to update a registrant's status.  **Scopes:** `recording:write:admin`, `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meeting_recording_registrant_status_with_http_info(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body68 body: (required)
        :param int meeting_id: The meeting ID in **long** format. The data type of this field is \"long\"(represented as int64 in JSON).  While storing it in your database, store it as a **long** data type and **not as an integer**, as the Meeting IDs can be longer than 10 digits. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method meeting_recording_registrant_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `meeting_recording_registrant_status`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `meeting_recording_registrant_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('action', params['action']))  # noqa: E501
        if 'registrants' in params:
            form_params.append(('registrants', params['registrants']))  # noqa: E501
            collection_formats['registrants'] = 'multi'  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/registrants/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def meeting_recording_registrant_status(self, action, registrants, meeting_id, **kwargs):  # noqa: E501
        """Update Recording Registrant's Status  # noqa: E501

        A registrant can either be approved or denied from viewing the [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) recording.  Use this API to update a registrant's status.  **Scopes:** `recording:write:admin`, `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meeting_recording_registrant_status(action, registrants, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: (required)
        :param list[MeetingsmeetingIdrecordingsregistrantsstatusRegistrants] registrants: (required)
        :param int meeting_id: The meeting ID in **long** format. The data type of this field is \"long\"(represented as int64 in JSON).  While storing it in your database, store it as a **long** data type and **not as an integer**, as the Meeting IDs can be longer than 10 digits. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.meeting_recording_registrant_status_with_http_info(action, registrants, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.meeting_recording_registrant_status_with_http_info(action, registrants, meeting_id, **kwargs)  # noqa: E501
            return data

    def meeting_recording_registrant_status_with_http_info(self, action, registrants, meeting_id, **kwargs):  # noqa: E501
        """Update Recording Registrant's Status  # noqa: E501

        A registrant can either be approved or denied from viewing the [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) recording.  Use this API to update a registrant's status.  **Scopes:** `recording:write:admin`, `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meeting_recording_registrant_status_with_http_info(action, registrants, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: (required)
        :param list[MeetingsmeetingIdrecordingsregistrantsstatusRegistrants] registrants: (required)
        :param int meeting_id: The meeting ID in **long** format. The data type of this field is \"long\"(represented as int64 in JSON).  While storing it in your database, store it as a **long** data type and **not as an integer**, as the Meeting IDs can be longer than 10 digits. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action', 'registrants', 'meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method meeting_recording_registrant_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `meeting_recording_registrant_status`")  # noqa: E501
        # verify the required parameter 'registrants' is set
        if ('registrants' not in params or
                params['registrants'] is None):
            raise ValueError("Missing the required parameter `registrants` when calling `meeting_recording_registrant_status`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `meeting_recording_registrant_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('action', params['action']))  # noqa: E501
        if 'registrants' in params:
            form_params.append(('registrants', params['registrants']))  # noqa: E501
            collection_formats['registrants'] = 'multi'  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/registrants/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def meeting_recording_registrants(self, meeting_id, **kwargs):  # noqa: E501
        """List Recording Registrants  # noqa: E501

        Cloud Recordings of past Zoom Meetings can be made [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings). Users should be [registered](https://marketplace.zoom.us/docs/api-reference/zoom-api/cloud-recording/meetingrecordingregistrantcreate) to view these recordings.  Use this API to list registrants of **On-demand Cloud Recordings** of a past meeting.<br> **Scopes:** `recording:read:admin`, `recording:read`.<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meeting_recording_registrants(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int meeting_id: The meeting ID in **long** format. The data type of this field is \"long\"(represented as int64 in JSON).  While storing it in your database, store it as a **long** data type and **not as an integer**, as the Meeting IDs can be longer than 10 digits. (required)
        :param str status: The registrant status:<br>`pending` - Registrant's status is pending.<br>`approved` - Registrant's status is approved.<br>`denied` - Registrant's status is denied.
        :param int page_size: The number of records returned within a single API call.
        :param int page_number: The current page number of returned records.
        :return: RegistrationList1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.meeting_recording_registrants_with_http_info(meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.meeting_recording_registrants_with_http_info(meeting_id, **kwargs)  # noqa: E501
            return data

    def meeting_recording_registrants_with_http_info(self, meeting_id, **kwargs):  # noqa: E501
        """List Recording Registrants  # noqa: E501

        Cloud Recordings of past Zoom Meetings can be made [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings). Users should be [registered](https://marketplace.zoom.us/docs/api-reference/zoom-api/cloud-recording/meetingrecordingregistrantcreate) to view these recordings.  Use this API to list registrants of **On-demand Cloud Recordings** of a past meeting.<br> **Scopes:** `recording:read:admin`, `recording:read`.<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meeting_recording_registrants_with_http_info(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int meeting_id: The meeting ID in **long** format. The data type of this field is \"long\"(represented as int64 in JSON).  While storing it in your database, store it as a **long** data type and **not as an integer**, as the Meeting IDs can be longer than 10 digits. (required)
        :param str status: The registrant status:<br>`pending` - Registrant's status is pending.<br>`approved` - Registrant's status is approved.<br>`denied` - Registrant's status is denied.
        :param int page_size: The number of records returned within a single API call.
        :param int page_number: The current page number of returned records.
        :return: RegistrationList1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meeting_id', 'status', 'page_size', 'page_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method meeting_recording_registrants" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `meeting_recording_registrants`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'page_number' in params:
            query_params.append(('page_number', params['page_number']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/registrants', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationList1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_delete(self, meeting_id, **kwargs):  # noqa: E501
        """Delete Meeting Recordings  # noqa: E501

        Delete all recording files of a meeting.<br><br>  **Scopes:** `recording:write:admin` `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br> **Prerequisites**: * Cloud Recording should be enabled on the user's account.<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_delete(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :param str action: The recording delete actions:<br>`trash` - Move recording to trash.<br>`delete` - Delete recording permanently.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_delete_with_http_info(meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_delete_with_http_info(meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_delete_with_http_info(self, meeting_id, **kwargs):  # noqa: E501
        """Delete Meeting Recordings  # noqa: E501

        Delete all recording files of a meeting.<br><br>  **Scopes:** `recording:write:admin` `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br> **Prerequisites**: * Cloud Recording should be enabled on the user's account.<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_delete_with_http_info(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :param str action: The recording delete actions:<br>`trash` - Move recording to trash.<br>`delete` - Delete recording permanently.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meeting_id', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_delete_one(self, meeting_id, recording_id, **kwargs):  # noqa: E501
        """Delete a Meeting Recording File  # noqa: E501

        Delete a sprecific recording file from a meeting.<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>  <br>  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_delete_one(meeting_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :param str recording_id: The recording ID. (required)
        :param str action: The recording delete actions:<br>`trash` - Move recording to trash.<br>`delete` - Delete recording permanently.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_delete_one_with_http_info(meeting_id, recording_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_delete_one_with_http_info(meeting_id, recording_id, **kwargs)  # noqa: E501
            return data

    def recording_delete_one_with_http_info(self, meeting_id, recording_id, **kwargs):  # noqa: E501
        """Delete a Meeting Recording File  # noqa: E501

        Delete a sprecific recording file from a meeting.<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>  <br>  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_delete_one_with_http_info(meeting_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :param str recording_id: The recording ID. (required)
        :param str action: The recording delete actions:<br>`trash` - Move recording to trash.<br>`delete` - Delete recording permanently.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meeting_id', 'recording_id', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_delete_one" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_delete_one`")  # noqa: E501
        # verify the required parameter 'recording_id' is set
        if ('recording_id' not in params or
                params['recording_id'] is None):
            raise ValueError("Missing the required parameter `recording_id` when calling `recording_delete_one`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501
        if 'recording_id' in params:
            path_params['recordingId'] = params['recording_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/{recordingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_get(self, meeting_id, **kwargs):  # noqa: E501
        """Get Meeting Recordings  # noqa: E501

        Get all the [recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording#h_7420acb5-1897-4061-87b4-5b76e99c03b4) from a meeting.<br><br> The recording files can be downloaded via the `download_url` property listed in the response.  > To access a password protected cloud recording, add an \"access_token\" parameter to the download URL and provide [JWT](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app) as the value of the \"access_token\". <br>  **Scopes:** `recording:read:admin` `recording:read`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_get(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_get_with_http_info(meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_get_with_http_info(meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_get_with_http_info(self, meeting_id, **kwargs):  # noqa: E501
        """Get Meeting Recordings  # noqa: E501

        Get all the [recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording#h_7420acb5-1897-4061-87b4-5b76e99c03b4) from a meeting.<br><br> The recording files can be downloaded via the `download_url` property listed in the response.  > To access a password protected cloud recording, add an \"access_token\" parameter to the download URL and provide [JWT](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app) as the value of the \"access_token\". <br>  **Scopes:** `recording:read:admin` `recording:read`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_get_with_http_info(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_registrant_question_update(self, body, meeting_id, **kwargs):  # noqa: E501
        """Update Registration Questions  # noqa: E501

        For [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) meeting recordings, you can include fields with questions that will be shown to registrants when they register to view the recording.  Use this API to update registration questions that are to be answered by users while registering to view a recording.<br> **Scopes:** `recording:write:admin`, `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_registrant_question_update(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body70 body: Recording Registrant Questions (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_registrant_question_update_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_registrant_question_update_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_registrant_question_update_with_http_info(self, body, meeting_id, **kwargs):  # noqa: E501
        """Update Registration Questions  # noqa: E501

        For [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) meeting recordings, you can include fields with questions that will be shown to registrants when they register to view the recording.  Use this API to update registration questions that are to be answered by users while registering to view a recording.<br> **Scopes:** `recording:write:admin`, `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_registrant_question_update_with_http_info(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body70 body: Recording Registrant Questions (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_registrant_question_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `recording_registrant_question_update`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_registrant_question_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/registrants/questions', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_registrants_questions_get(self, meeting_id, **kwargs):  # noqa: E501
        """Get Registration Questions  # noqa: E501

        For [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) meeting recordings, you can include fields with questions that will be shown to registrants when they register to view the recording.  Use this API to retrieve a list of questions that are displayed for users to complete when registering to view the recording of a specific meeting.<br> **Scopes:** `recording:read:admin`, `recording:read`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_registrants_questions_get(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: RecordingRegistrantQuestions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_registrants_questions_get_with_http_info(meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_registrants_questions_get_with_http_info(meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_registrants_questions_get_with_http_info(self, meeting_id, **kwargs):  # noqa: E501
        """Get Registration Questions  # noqa: E501

        For [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) meeting recordings, you can include fields with questions that will be shown to registrants when they register to view the recording.  Use this API to retrieve a list of questions that are displayed for users to complete when registering to view the recording of a specific meeting.<br> **Scopes:** `recording:read:admin`, `recording:read`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_registrants_questions_get_with_http_info(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: RecordingRegistrantQuestions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_registrants_questions_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_registrants_questions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/registrants/questions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordingRegistrantQuestions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_setting_update(self, meeting_id, **kwargs):  # noqa: E501
        """Get Meeting Recording Settings  # noqa: E501

        Retrieve settings applied to a meeting's [Cloud Recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording).<br><br> **Scopes**: `recording:read:admin` `recording:read`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_setting_update(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: RecordingSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_setting_update_with_http_info(meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_setting_update_with_http_info(meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_setting_update_with_http_info(self, meeting_id, **kwargs):  # noqa: E501
        """Get Meeting Recording Settings  # noqa: E501

        Retrieve settings applied to a meeting's [Cloud Recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording).<br><br> **Scopes**: `recording:read:admin` `recording:read`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_setting_update_with_http_info(meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: RecordingSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_setting_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_setting_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordingSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_settings_update(self, body, meeting_id, **kwargs):  # noqa: E501
        """Update Meeting Recording Settings  # noqa: E501

        Update settings applied to a meeting's [Cloud Recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording)<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_settings_update(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RecordingSettings1 body: Meeting recording Settings (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_settings_update_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_settings_update_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_settings_update_with_http_info(self, body, meeting_id, **kwargs):  # noqa: E501
        """Update Meeting Recording Settings  # noqa: E501

        Update settings applied to a meeting's [Cloud Recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording)<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_settings_update_with_http_info(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RecordingSettings1 body: Meeting recording Settings (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_settings_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_settings_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'share_recording' in params:
            form_params.append(('share_recording', params['share_recording']))  # noqa: E501
        if 'recording_authentication' in params:
            form_params.append(('recording_authentication', params['recording_authentication']))  # noqa: E501
        if 'authentication_option' in params:
            form_params.append(('authentication_option', params['authentication_option']))  # noqa: E501
        if 'authentication_domains' in params:
            form_params.append(('authentication_domains', params['authentication_domains']))  # noqa: E501
        if 'viewer_download' in params:
            form_params.append(('viewer_download', params['viewer_download']))  # noqa: E501
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501
        if 'on_demand' in params:
            form_params.append(('on_demand', params['on_demand']))  # noqa: E501
        if 'approval_type' in params:
            form_params.append(('approval_type', params['approval_type']))  # noqa: E501
        if 'send_email_to_host' in params:
            form_params.append(('send_email_to_host', params['send_email_to_host']))  # noqa: E501
        if 'show_social_share_buttons' in params:
            form_params.append(('show_social_share_buttons', params['show_social_share_buttons']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/settings', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_settings_update(self, share_recording, recording_authentication, authentication_option, authentication_domains, viewer_download, password, on_demand, approval_type, send_email_to_host, show_social_share_buttons, meeting_id, **kwargs):  # noqa: E501
        """Update Meeting Recording Settings  # noqa: E501

        Update settings applied to a meeting's [Cloud Recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording)<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_settings_update(share_recording, recording_authentication, authentication_option, authentication_domains, viewer_download, password, on_demand, approval_type, send_email_to_host, show_social_share_buttons, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str share_recording: (required)
        :param bool recording_authentication: (required)
        :param str authentication_option: (required)
        :param str authentication_domains: (required)
        :param bool viewer_download: (required)
        :param str password: (required)
        :param bool on_demand: (required)
        :param int approval_type: (required)
        :param bool send_email_to_host: (required)
        :param bool show_social_share_buttons: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_settings_update_with_http_info(share_recording, recording_authentication, authentication_option, authentication_domains, viewer_download, password, on_demand, approval_type, send_email_to_host, show_social_share_buttons, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_settings_update_with_http_info(share_recording, recording_authentication, authentication_option, authentication_domains, viewer_download, password, on_demand, approval_type, send_email_to_host, show_social_share_buttons, meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_settings_update_with_http_info(self, share_recording, recording_authentication, authentication_option, authentication_domains, viewer_download, password, on_demand, approval_type, send_email_to_host, show_social_share_buttons, meeting_id, **kwargs):  # noqa: E501
        """Update Meeting Recording Settings  # noqa: E501

        Update settings applied to a meeting's [Cloud Recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording)<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_settings_update_with_http_info(share_recording, recording_authentication, authentication_option, authentication_domains, viewer_download, password, on_demand, approval_type, send_email_to_host, show_social_share_buttons, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str share_recording: (required)
        :param bool recording_authentication: (required)
        :param str authentication_option: (required)
        :param str authentication_domains: (required)
        :param bool viewer_download: (required)
        :param str password: (required)
        :param bool on_demand: (required)
        :param int approval_type: (required)
        :param bool send_email_to_host: (required)
        :param bool show_social_share_buttons: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['share_recording', 'recording_authentication', 'authentication_option', 'authentication_domains', 'viewer_download', 'password', 'on_demand', 'approval_type', 'send_email_to_host', 'show_social_share_buttons', 'meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_settings_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'share_recording' is set
        if ('share_recording' not in params or
                params['share_recording'] is None):
            raise ValueError("Missing the required parameter `share_recording` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'recording_authentication' is set
        if ('recording_authentication' not in params or
                params['recording_authentication'] is None):
            raise ValueError("Missing the required parameter `recording_authentication` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'authentication_option' is set
        if ('authentication_option' not in params or
                params['authentication_option'] is None):
            raise ValueError("Missing the required parameter `authentication_option` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'authentication_domains' is set
        if ('authentication_domains' not in params or
                params['authentication_domains'] is None):
            raise ValueError("Missing the required parameter `authentication_domains` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'viewer_download' is set
        if ('viewer_download' not in params or
                params['viewer_download'] is None):
            raise ValueError("Missing the required parameter `viewer_download` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'on_demand' is set
        if ('on_demand' not in params or
                params['on_demand'] is None):
            raise ValueError("Missing the required parameter `on_demand` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'approval_type' is set
        if ('approval_type' not in params or
                params['approval_type'] is None):
            raise ValueError("Missing the required parameter `approval_type` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'send_email_to_host' is set
        if ('send_email_to_host' not in params or
                params['send_email_to_host'] is None):
            raise ValueError("Missing the required parameter `send_email_to_host` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'show_social_share_buttons' is set
        if ('show_social_share_buttons' not in params or
                params['show_social_share_buttons'] is None):
            raise ValueError("Missing the required parameter `show_social_share_buttons` when calling `recording_settings_update`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_settings_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'share_recording' in params:
            form_params.append(('share_recording', params['share_recording']))  # noqa: E501
        if 'recording_authentication' in params:
            form_params.append(('recording_authentication', params['recording_authentication']))  # noqa: E501
        if 'authentication_option' in params:
            form_params.append(('authentication_option', params['authentication_option']))  # noqa: E501
        if 'authentication_domains' in params:
            form_params.append(('authentication_domains', params['authentication_domains']))  # noqa: E501
        if 'viewer_download' in params:
            form_params.append(('viewer_download', params['viewer_download']))  # noqa: E501
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501
        if 'on_demand' in params:
            form_params.append(('on_demand', params['on_demand']))  # noqa: E501
        if 'approval_type' in params:
            form_params.append(('approval_type', params['approval_type']))  # noqa: E501
        if 'send_email_to_host' in params:
            form_params.append(('send_email_to_host', params['send_email_to_host']))  # noqa: E501
        if 'show_social_share_buttons' in params:
            form_params.append(('show_social_share_buttons', params['show_social_share_buttons']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/settings', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_status_update(self, body, meeting_id, **kwargs):  # noqa: E501
        """Recover Meeting Recordings  # noqa: E501

        Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover all deleted [Cloud Recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) of a specific meeting.<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br> **Prerequisites**:<br> * A Pro user with Cloud Recording enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_status_update(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body62 body: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_status_update_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_status_update_with_http_info(body, meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_status_update_with_http_info(self, body, meeting_id, **kwargs):  # noqa: E501
        """Recover Meeting Recordings  # noqa: E501

        Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover all deleted [Cloud Recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) of a specific meeting.<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br> **Prerequisites**:<br> * A Pro user with Cloud Recording enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_status_update_with_http_info(body, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body62 body: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_status_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `recording_status_update`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_status_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('action', params['action']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_status_update(self, action, meeting_id, **kwargs):  # noqa: E501
        """Recover Meeting Recordings  # noqa: E501

        Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover all deleted [Cloud Recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) of a specific meeting.<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br> **Prerequisites**:<br> * A Pro user with Cloud Recording enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_status_update(action, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_status_update_with_http_info(action, meeting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_status_update_with_http_info(action, meeting_id, **kwargs)  # noqa: E501
            return data

    def recording_status_update_with_http_info(self, action, meeting_id, **kwargs):  # noqa: E501
        """Recover Meeting Recordings  # noqa: E501

        Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover all deleted [Cloud Recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) of a specific meeting.<br><br> **Scopes**: `recording:write:admin` `recording:write`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br> **Prerequisites**:<br> * A Pro user with Cloud Recording enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_status_update_with_http_info(action, meeting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action', 'meeting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_status_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `recording_status_update`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_status_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('action', params['action']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_status_update_one(self, body, meeting_id, recording_id, **kwargs):  # noqa: E501
        """Recover a Single Recording  # noqa: E501

        Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover a single recording file from the meeting.<br> **Scopes:** `recording:write:admin` `recording:write`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_status_update_one(body, meeting_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body64 body: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :param str recording_id: The recording ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_status_update_one_with_http_info(body, meeting_id, recording_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_status_update_one_with_http_info(body, meeting_id, recording_id, **kwargs)  # noqa: E501
            return data

    def recording_status_update_one_with_http_info(self, body, meeting_id, recording_id, **kwargs):  # noqa: E501
        """Recover a Single Recording  # noqa: E501

        Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover a single recording file from the meeting.<br> **Scopes:** `recording:write:admin` `recording:write`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_status_update_one_with_http_info(body, meeting_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body64 body: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :param str recording_id: The recording ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'meeting_id', 'recording_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_status_update_one" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `recording_status_update_one`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_status_update_one`")  # noqa: E501
        # verify the required parameter 'recording_id' is set
        if ('recording_id' not in params or
                params['recording_id'] is None):
            raise ValueError("Missing the required parameter `recording_id` when calling `recording_status_update_one`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501
        if 'recording_id' in params:
            path_params['recordingId'] = params['recording_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('action', params['action']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/{recordingId}/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recording_status_update_one(self, action, meeting_id, recording_id, **kwargs):  # noqa: E501
        """Recover a Single Recording  # noqa: E501

        Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover a single recording file from the meeting.<br> **Scopes:** `recording:write:admin` `recording:write`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_status_update_one(action, meeting_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :param str recording_id: The recording ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recording_status_update_one_with_http_info(action, meeting_id, recording_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recording_status_update_one_with_http_info(action, meeting_id, recording_id, **kwargs)  # noqa: E501
            return data

    def recording_status_update_one_with_http_info(self, action, meeting_id, recording_id, **kwargs):  # noqa: E501
        """Recover a Single Recording  # noqa: E501

        Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover a single recording file from the meeting.<br> **Scopes:** `recording:write:admin` `recording:write`<br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recording_status_update_one_with_http_info(action, meeting_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: (required)
        :param str meeting_id: The meeting ID or meeting UUID. If the meeting ID is provided instead of UUID,the response will be for the latest meeting instance. If a UUID starts with \"/\" or contains \"//\" (example: \"/ajXp112QmuoKj4854875==\"), you must **double encode** the UUID before making an API request.  (required)
        :param str recording_id: The recording ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action', 'meeting_id', 'recording_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recording_status_update_one" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `recording_status_update_one`")  # noqa: E501
        # verify the required parameter 'meeting_id' is set
        if ('meeting_id' not in params or
                params['meeting_id'] is None):
            raise ValueError("Missing the required parameter `meeting_id` when calling `recording_status_update_one`")  # noqa: E501
        # verify the required parameter 'recording_id' is set
        if ('recording_id' not in params or
                params['recording_id'] is None):
            raise ValueError("Missing the required parameter `recording_id` when calling `recording_status_update_one`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meeting_id' in params:
            path_params['meetingId'] = params['meeting_id']  # noqa: E501
        if 'recording_id' in params:
            path_params['recordingId'] = params['recording_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'action' in params:
            form_params.append(('action', params['action']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/meetings/{meetingId}/recordings/{recordingId}/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recordings_list(self, user_id, **kwargs):  # noqa: E501
        """List All Recordings  # noqa: E501

        When a user records a meeting by choosing the **Record to the Cloud** option, the video, audio, and chat text are recorded in the Zoom cloud.   Use this API to list all [Cloud recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) of a user.<br> > To access a user's password protected cloud recording, add an \"access_token\" parameter to the download URL and provide either the [JWT](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app) or the user's OAuth access token as the value of the \"access_token\" parameter.  <br>  **Scopes:** `recording:read:admin` `recording:read`  <br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br> **Prerequisites:**  * Pro or a higher plan. * Cloud Recording must be enabled on the user's account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recordings_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user ID or email address of the user. For user-level apps, pass `me` as the value for userId. (required)
        :param int page_size: The number of records returned within a single API call.
        :param str next_page_token: The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
        :param str mc: Query Metadata of Recording if an On-Premise Meeting Connector was used for the meeting.
        :param bool trash: Query trash. `true`: List recordings from trash.<br> `false`: Do not list recordings from the trash.<br> The default value is `false`. If you set it to `true`, you can use the `trash_type` property to indicate the type of Cloud recording that you need to retrieve. 
        :param date _from: Start date in 'yyyy-mm-dd' format. (Within 6 month range)  **Note**: The \"trash\" files cannot be filtered by date range and thus, the \"from\" and \"to\" fields should not be used for trash files.
        :param date to: End date in 'yyyy-mm-dd' format. (Within 6 month range)
        :param str trash_type: The type of Cloud recording that you would like to retrieve from the trash. The value can be one of the following:<br>     `meeting_recordings`: List all meeting recordings from the trash.<br>     `recording_file`: List all individual recording files from the trash. 
        :return: RecordingList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recordings_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.recordings_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def recordings_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List All Recordings  # noqa: E501

        When a user records a meeting by choosing the **Record to the Cloud** option, the video, audio, and chat text are recorded in the Zoom cloud.   Use this API to list all [Cloud recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) of a user.<br> > To access a user's password protected cloud recording, add an \"access_token\" parameter to the download URL and provide either the [JWT](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app) or the user's OAuth access token as the value of the \"access_token\" parameter.  <br>  **Scopes:** `recording:read:admin` `recording:read`  <br>    **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br> **Prerequisites:**  * Pro or a higher plan. * Cloud Recording must be enabled on the user's account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recordings_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user ID or email address of the user. For user-level apps, pass `me` as the value for userId. (required)
        :param int page_size: The number of records returned within a single API call.
        :param str next_page_token: The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
        :param str mc: Query Metadata of Recording if an On-Premise Meeting Connector was used for the meeting.
        :param bool trash: Query trash. `true`: List recordings from trash.<br> `false`: Do not list recordings from the trash.<br> The default value is `false`. If you set it to `true`, you can use the `trash_type` property to indicate the type of Cloud recording that you need to retrieve. 
        :param date _from: Start date in 'yyyy-mm-dd' format. (Within 6 month range)  **Note**: The \"trash\" files cannot be filtered by date range and thus, the \"from\" and \"to\" fields should not be used for trash files.
        :param date to: End date in 'yyyy-mm-dd' format. (Within 6 month range)
        :param str trash_type: The type of Cloud recording that you would like to retrieve from the trash. The value can be one of the following:<br>     `meeting_recordings`: List all meeting recordings from the trash.<br>     `recording_file`: List all individual recording files from the trash. 
        :return: RecordingList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'page_size', 'next_page_token', 'mc', 'trash', '_from', 'to', 'trash_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recordings_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `recordings_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'next_page_token' in params:
            query_params.append(('next_page_token', params['next_page_token']))  # noqa: E501
        if 'mc' in params:
            query_params.append(('mc', params['mc']))  # noqa: E501
        if 'trash' in params:
            query_params.append(('trash', params['trash']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'trash_type' in params:
            query_params.append(('trash_type', params['trash_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/recordings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordingList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
